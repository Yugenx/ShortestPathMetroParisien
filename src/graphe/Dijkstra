package graphe;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Collections;

import graphe.Arc;
import graphe.IGrapheConst;

public class Dijkstra {

    public static void plusCourtChemin(IGrapheConst graphe, String depart, String arrivee, List<String> chemin) {
        Map<String, Integer> d = new HashMap<>(); // Map des distances minimales
        Map<String, String> predecesseur = new HashMap<>(); // Map des prédécesseurs
        List<String> nonVisites = new ArrayList<>(); // Liste des sommets non visités

        // Initialisation
        for (String sommet : graphe.getSommets()) {
            d.put(sommet, Integer.MAX_VALUE);
            predecesseur.put(sommet, null);
            nonVisites.add(sommet);
        }

        d.put(depart, 0);

        while (!nonVisites.isEmpty()) {
            String u = getMinimum(nonVisites, d);
            nonVisites.remove(u);

            if (u.equals(arrivee)) {
                break;
            }

            for (String v : graphe.getSucc(u)) {
                if (nonVisites.contains(v)) {
                    int poidsUV = graphe.getValuation(u, v);
                    int nouvelleDistance = d.get(u) + poidsUV;
                    if (nouvelleDistance < d.get(v)) {
                        d.put(v, nouvelleDistance);
                        predecesseur.put(v, u);
                    }
                }
            }
        }

        // Construire le chemin
        String u = arrivee;
        while (predecesseur.get(u) != null) {
            chemin.add(0, u);
            u = predecesseur.get(u);
        }
        chemin.add(0, u);
    }

    private static String getMinimum(List<String> nonVisites, Map<String, Integer> d) {
        String min = nonVisites.get(0);
        for (String sommet : nonVisites) {
            if (d.get(sommet) < d.get(min)) {
                min = sommet;
            }
        }
        return min;
    }

    private static List<String> getPlusCourtChemin(Map<String, Integer> d, Map<String, String> predecesseurs, String depart, String arrivee) {
        List<String> chemin = new ArrayList<>();
        if (!predecesseurs.containsKey(arrivee)) {
            return chemin;
        }
        String sommet = arrivee;
        chemin.add(sommet);
        while (!sommet.equals(depart)) {
            sommet = predecesseurs.get(sommet);
            chemin.add(sommet);
        }
        Collections.reverse(chemin);
        return chemin;
    }
}

